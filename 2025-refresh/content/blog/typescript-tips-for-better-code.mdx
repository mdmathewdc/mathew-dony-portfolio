---
title: "TypeScript Tips for Better Code"
date: "2024-03-10"
category: "Career"
views: 892
caption: "Practical TypeScript tips and tricks to improve type safety and developer experience."
---

TypeScript has become the de facto standard for building robust JavaScript applications. But there's a difference between using TypeScript and using it *well*. Let's explore some practical tips that will level up your TypeScript game.

## Tip 1: Use `unknown` Instead of `any`

When you don't know the type of a value, reach for `unknown` instead of `any`:

```typescript
// ❌ Bad - loses all type safety
function processData(data: any) {
  return data.toUpperCase(); // No error, but crashes at runtime if data isn't a string
}

// ✅ Good - forces you to narrow the type
function processData(data: unknown) {
  if (typeof data === 'string') {
    return data.toUpperCase(); // TypeScript knows data is a string here
  }
  throw new Error('Data must be a string');
}
```

`unknown` forces you to perform runtime checks before using the value, making your code safer.

## Tip 2: Leverage Type Guards

Type guards help TypeScript understand your runtime checks:

```typescript
interface User {
  name: string;
  email: string;
}

interface Admin extends User {
  permissions: string[];
}

// Type guard function
function isAdmin(user: User | Admin): user is Admin {
  return 'permissions' in user;
}

function greet(user: User | Admin) {
  if (isAdmin(user)) {
    console.log(`Admin ${user.name} has ${user.permissions.length} permissions`);
  } else {
    console.log(`Hello, ${user.name}`);
  }
}
```

The `user is Admin` syntax tells TypeScript to narrow the type within the conditional block.

## Tip 3: Use Discriminated Unions for Better Type Safety

Discriminated unions make complex state management type-safe:

```typescript
type RequestState =
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'success'; data: User[] }
  | { status: 'error'; error: string };

function handleRequest(state: RequestState) {
  switch (state.status) {
    case 'idle':
      return <div>Click to load</div>;
    case 'loading':
      return <Spinner />;
    case 'success':
      return <UserList users={state.data} />; // TypeScript knows data exists
    case 'error':
      return <Error message={state.error} />; // TypeScript knows error exists
  }
}
```

Each state variant has a unique `status` discriminator, allowing TypeScript to narrow the type precisely.

## Tip 4: Utility Types Are Your Friends

TypeScript includes powerful built-in utility types:

```typescript
interface User {
  id: string;
  name: string;
  email: string;
  age: number;
}

// Pick specific properties
type UserPreview = Pick<User, 'id' | 'name'>;

// Omit specific properties
type UserWithoutEmail = Omit<User, 'email'>;

// Make all properties optional
type PartialUser = Partial<User>;

// Make all properties required
type RequiredUser = Required<Partial<User>>;

// Make all properties readonly
type ImmutableUser = Readonly<User>;

// Extract function return type
function getUser() {
  return { id: '1', name: 'John' };
}
type ReturnedUser = ReturnType<typeof getUser>;
```

These utilities reduce duplication and keep your types DRY.

## Tip 5: `const` Assertions for Literal Types

Use `as const` to get literal types instead of widened types:

```typescript
// Without const assertion
const colors = ['red', 'green', 'blue'];
// Type: string[]

// With const assertion
const colors = ['red', 'green', 'blue'] as const;
// Type: readonly ["red", "green", "blue"]

type Color = typeof colors[number];
// Type: "red" | "green" | "blue"
```

This is especially useful for configuration objects:

```typescript
const config = {
  apiUrl: 'https://api.example.com',
  timeout: 5000,
} as const;

// TypeScript prevents accidental mutations
// config.apiUrl = 'https://other-api.com'; // Error!
```

## Tip 6: Generic Constraints for Flexible Yet Safe Code

Constrain generics to ensure they have required properties:

```typescript
// ❌ Too loose - T could be anything
function getValue<T>(obj: T, key: string) {
  return obj[key]; // Error: no index signature
}

// ✅ Constrained generic
function getValue<T extends Record<string, any>, K extends keyof T>(
  obj: T,
  key: K
): T[K] {
  return obj[key]; // Type-safe!
}

const user = { name: 'John', age: 30 };
const name = getValue(user, 'name'); // Type: string
const age = getValue(user, 'age');   // Type: number
// getValue(user, 'invalid'); // Error: not a key of user
```

## Tip 7: Template Literal Types

Create sophisticated string types:

```typescript
type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';
type Route = '/users' | '/posts' | '/comments';

type APIEndpoint = `${HTTPMethod} ${Route}`;
// Type: "GET /users" | "GET /posts" | "GET /comments" | "POST /users" | ...

function makeRequest(endpoint: APIEndpoint) {
  // Only accepts valid combinations
}

makeRequest('GET /users');  // ✅
makeRequest('POST /posts'); // ✅
// makeRequest('PATCH /users'); // ❌ Error
```

## Tip 8: Infer Types from Runtime Values

Let TypeScript infer types instead of duplicating them:

```typescript
const ROLES = ['admin', 'editor', 'viewer'] as const;
type Role = typeof ROLES[number];
// Type: "admin" | "editor" | "viewer"

const STATUS_CODES = {
  OK: 200,
  CREATED: 201,
  BAD_REQUEST: 400,
  NOT_FOUND: 404,
} as const;

type StatusCode = typeof STATUS_CODES[keyof typeof STATUS_CODES];
// Type: 200 | 201 | 400 | 404
```

This keeps your source of truth in one place.

## Tip 9: Conditional Types for Advanced Patterns

Build types that depend on other types:

```typescript
type IsString<T> = T extends string ? true : false;

type A = IsString<'hello'>; // true
type B = IsString<number>;  // false

// More practical example
type AsyncReturnType<T> = T extends Promise<infer R> ? R : T;

async function fetchUser() {
  return { id: '1', name: 'John' };
}

type User = AsyncReturnType<ReturnType<typeof fetchUser>>;
// Type: { id: string; name: string; }
```

## Tip 10: Strict Configuration

Enable strict mode in your `tsconfig.json`:

```json
{
  "compilerOptions": {
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  }
}
```

These settings catch more potential bugs at compile time.

## Bonus: Type-Safe Event Handlers

Create type-safe event emitters:

```typescript
type Events = {
  'user:login': { userId: string; timestamp: Date };
  'user:logout': { userId: string };
  'message:received': { content: string; from: string };
};

class EventEmitter<T extends Record<string, any>> {
  on<K extends keyof T>(event: K, handler: (data: T[K]) => void) {
    // Implementation
  }

  emit<K extends keyof T>(event: K, data: T[K]) {
    // Implementation
  }
}

const emitter = new EventEmitter<Events>();

emitter.on('user:login', (data) => {
  console.log(data.userId, data.timestamp); // Fully typed!
});

// emitter.emit('user:login', { wrong: 'data' }); // Error!
emitter.emit('user:login', { userId: '123', timestamp: new Date() }); // ✅
```

## Conclusion

TypeScript is a powerful tool, but its true value emerges when you leverage its advanced features. These tips will help you write more maintainable, type-safe code.

Remember: the goal isn't to have perfect types everywhere—it's to catch bugs early and improve developer experience. Use these tools judiciously, and your future self will thank you!

---

*What's your favorite TypeScript feature? Share your tips in the comments!*

